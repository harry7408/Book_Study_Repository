# Class ,Objects와 Interface

## 다루는 내용

1. 클래스와 인터페이스
    1. 인터페이스도 프로퍼티를 선언할 수 있다
    2. Kotlin의 선언은 기본적으로 public + final 이다
    3. 중첩 Class는 기본적으로 inner class가 아니다</br>
    → 외부 Class에 대한 암시적 참조를 가지지 않는다
2. 복잡한 프로퍼티와 생성자
    1. 복잡한 초기화 로직에서 FULL 생성자 문법을 제공하여 직접 정의할 수 있다
    2. 프로퍼티도 getter와 setter를 직접 구현하여 Custom Logic을 추가할 수도 있다
3. Data 클래스
    1. data Class를 생성하면 toString, equals, hashCode, getter, setter 등의 코드를 자동으로 생성해준다
4. 클래스 위임
    1. 위임 메서드를 직접 작성할 필요 없이 Kotlin이 지원한다
5. Object 키워드
    1. Object 키워드를 사용하면 Class 선언과 동시에 인스턴스를 생성하는 역할을 한다
    2. Companion Object, Singleton Object, 객체 표현식 등을 정의할 수 있다

### Class 계층 정의

Kotlin에서의 가시성과 접근 제한자를 살펴본다</br>
→ 기본적으로 public + final

sealed Class에 대해서 살펴본다</br>
→ 특정 Class의 하위 클래스 또는 인터페이스의 구현을 제한할 수 있다

- Kotlin에서 Interface 사용하기
    - Kotlin의 인터페이스는 추상 메서드 뿐만 아니라 비추상 메서드의 구현도 포함할 수 있다</br>
    → 다만 인터페이스는 상태를 가질 수 없다
    - 인터페이스 구현 `Composition`과 상속 `Inheritance` 모두 뒤에 : 을 사용하여 표현할 수 있다</br>
    → 상속은 단일 상속만, 인터페이스는 제한 없이 가능하다
    - Kotlin에서 `override` 키워드를 필수로 사용해야한다</br>
    → 실수로 메서드를 오버라이딩 하는 것을 방지하기 위함 (컴파일 에러 발생)
    - Kotlin에서 인터페이스 메서드는 기본 구현체를 가질 수 있다</br>
    → 메서드의 body를 제공하면 기본 동작을 정의 가능하다 (인터페이스 메서드 초기화?)
    - 인터페이스의 추상 메서드는 반드시 구현해야하고 기본 구현체를 가지는 메서드는 override 가능하다</br>
    → 같은 이름의 Default 메서드가 여러 인터페이스에 정의되어 있을 때 여러 인터페이스를 구현하는 Class에서는 직접 정의 해줘야 한다. (그냥 사용하게 되면 Compiler가 어떤 Default 메서드를 사용 해야 할 지 모른다)
    
    > EX)
    > 
    
    ```kotlin
    interface Clickable {
    	// 추상메서드 1개 (SAM)
    	// 추상 Class가 아닌 Class들은 이 메서드를 반드시 구현해야한다
    	fun click()
    }
    
    class Button : Clickable {
    	override fun click() = println("clicked")
    }
    
    fun main() {
    	Button().click()
    }
    -----------
    clicked
    -----------
    // 기본 구현체를 가지고 있는 인터페이스
    interface Touchable {
    	fun touch()
    	fun show() {
    		println("touched")
    	}
    }
    
    interface Focusable {
    	fun focus(flag: Boolean) {
    		println("I am ${if (flag) "got" else "lost"} focus")
    	}
    	
    	fun show() {
    		println("focused")
    	}
    }
    
    class CardView : Touchable, Focusable {
    	override fun touch() = println("I am touched")
    	
    	// 직접 구현하지 않으면 Compile error 발생
    	override fun show() {
    		// super : 부모 인터페이스 <> : 어떤 인터페이스인지
    		super<Focusable>.show()
    		super<Touchable>.show()
    	}
    }
    
    fun main() {
    	 val cardView = CardView()
    	 cardView.showOff()
    	 cardView.focus(true)
    	 cardView.touch()
    }
    ---------------
    focused
    touched
    I am got focus
    I am touched
    
    ``` 
    💡 Kotlin에서는 Default 메서드를 포함하는 인터페이스를 일반 인터페이스와 정적 메서드 클래스로 나누어 컴파일 한다
    </br>**→ 인터페이스 자체는 선언만 포함하고 모든 구현 내용은 정적 메서드를 포함하는 별도의 클래스에서 관리한다 
    (Java로 마이그레이션 하려면 Default 메서드 까지도 직접 구현해줘야 한다)**
