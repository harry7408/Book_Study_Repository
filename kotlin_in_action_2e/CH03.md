# 함수 정의 및 호출

## 다루는 내용

1. Collection, 문자열, 정규 표현식을 다루는 함수
2. 지명 인자, 기본 매개변수 값, 중위 호출
3. 확장 함수 및 확장 프로퍼티를 통해 Java 라이브러리를 Kotiln에 적용
4. local, 최상위 함수와 프로퍼티를 통한 코드 구조화

### Kotlin에서 Collection 만드는 방법

- 앞 장에서 sefOf를 사용하여 Set Collection을 만든 것처럼 [collection name]Of 를 통해 원하는 Collection을 만들 수 있다<br>
→ Java의 표준 Collection을 사용한다 (Collection에 대한 Class를 재구현하지 않는다)

💡 .javaClass로 클래스에 대한 정보를 얻어올 수 있다

```kotlin
// 3개의 Collection 모두 read-only 
// set
val set = setOf(1,2,3)

// list
val list = listOf(1,2,3)

// map (key-value 구조이므로 to 사용)
val map = mapOf(1 to "one", 2 to "two", 3 to "three")

println(set.javaClass)
println(list.javaClass)
println(map.javaClass)
----------------------
class java.util.LinkedHashSet 
class java.util.Arrays$ArrayList
class java.util.LinkedHashMap
```

⭐ Java의 Collection을 그대로 사용하지만 추가로 더 유용하게 사용할 수 있다

> EX)
> 

```kotlin
fun main() {
	val strings = listOf("one","two","three")
	val numbers = setOf(1,2,3)
		
	println(strings.last())
	
	println(strings.shuffled())
	println(numbers.sum())
}
---------------------
three
[three, two, one]
6
```

### 함수 호출을 더 쉽게

Java의 Default로 구현된 toString과 다르게 출력하려면 third Party 라이브러리를 활용하거나 직접 로직을 구현해야하나 Kotlin은 표준 라이브러리에서 기본적으로 제공한다

```kotlin
fun main() {
	val list= listOf(1,2,3)
	// Default로 구현된 toString에 따라 출력
	print(list)
}
------------
[1,2,3]
------------

fun <T> joinToString(
	collection: Collection<T>,
	separator: String,
	prefix: String,
	postfix: String
) : String {
	val result=StringBuilder(prefix)
	
	for((index,element) in collection.withIndex()) {
		if(index>0) result.append(separator)
		result.append(element)
	}
	
	result.append(postfix)
	return result.toString()
}

fun main() {
	val list=listOf(1,2,3)
	println(joinToString(list,"; ","(",")"))
}
---------------
(1; 2; 3)
```

- 지명 인자
    
    ⭐ Java에서는 컴파일된 바이트코드에서 매개변수 이름이 유지되지 않아 지명인자를 지원하지 않는다 (매개변수 순서만 인식)
    
    - 위의 joinToString 메서드는 인자가 4개나 들어있고 어떤 순서로 입력을 해야하는지 다 파악하고 있어야 한다<br>
    → 함수의 시그니처만 보고는 파악하기 힘들다
    - 인자가 많은 경우 주석으로 이를 작성하는 것을 요구하기도 한다
    - Kotlin은 지명 인자를 지원하여 인자가 어떤 의미인지 파악하기 쉽고 순서를 지키지 않아도 된다<br>
    → 인자를 모두 명시해도 되고 일부만 명시해도 된다
    
    > EX)
    > 
    
    ```kotlin
    // Java
    joinToString(collection, /* seperator*/ " ", /*prefix*/, ",")
    
    // Kotlin
    joinToString(collection, seperator=" ", prefix=", " ...)
    ```
    
    ⭐ IntelliJ 나 Android Studio에서 함수의 인자를 바꿀 땐 직접 변경하지 말고 rename이나 Change Signaturre Action으로 일괄 변경하는 것이좋다
    
- 매개변수 기본 값
    
    ⭐ Java에서는 기본 값을 지원하지 않고 메서드 오버로딩을 사용해서 기본 값을 처리해야 한다 (함수 호출을 정적으로 결정하는 구조이기 때문에생성자를 여러개 만들어야 함)
    
    - Java의 특정 클래스에서는 과하게 많이 overload 된 메서드가 존재하여 반복적인 코드가 많아진다
    - 매개변수 값에 default 값을 지정할 수 있어 overload 된 메서드를 만들 필요가 없는 경우가 많다
    - 예시의 마지막처럼 생략할 때 함수의 시그니처만 보고 파악하기 어려운 경우가 있어 지명 인자와 함께 사용하면 시너지가 좋다
    - Default 값은 함수가 정의된 곳에 저장된다 (Call Site X)<br>
    → 기본 값이 바꾸고 호출할 때마다 새로운 기본 값을 사용하게 된다
    
    > EX)
    > 
    
    ```kotlin
    fun <T> joinToString(
    	collection: Collection<T>,
    	separator: String=", ",
    	prefix: String="",
    	postfix: String=""
    ) : String { ... }
    
    fun main() {
    	joinToString(list,", ","","")
    	joinToString(list)
    	// 이 경우 seperator가 ;가 된다 (생략하고자 하는 전까지는 순서 유지 필요)
    	joinToString(list,"; ")
    }
    ```
    
    💡 Java에서도 기본 값을 사용하려면 `@JvmOverloads` 를 사용하면 된다
    
    > EX)
    > 
    
    ```kotlin
     @JvmOverloads
     fun <T> joinToString(
     collection: Collection<T>,
     separator: String = ", ",
     prefix: String = "",
     postfix: String = ""
     ): String { /* ... */ }
     
    // @JvmOverloads를 붙이면 자동으로 오버라이딩 된 생성자를 만들어준다
     String joinToString(Collection<T> collection, String separator,
     String prefix, String postfix);
     
     String joinToString(Collection<T> collection, String separator,
     String prefix);
     
     String joinToString(Collection<T> collection, String separator);
     
     String joinToString(Collection<T> collection);
    ```
