# 함수 정의 및 호출

## 다루는 내용

1. Collection, 문자열, 정규 표현식을 다루는 함수
2. 지명 인자, 기본 매개변수 값, 중위 호출
3. 확장 함수 및 확장 프로퍼티를 통해 Java 라이브러리를 Kotiln에 적용
4. local, 최상위 함수와 프로퍼티를 통한 코드 구조화

### Kotlin에서 Collection 만드는 방법

- 앞 장에서 sefOf를 사용하여 Set Collection을 만든 것처럼 [collection name]Of 를 통해 원하는 Collection을 만들 수 있다<br>
→ Java의 표준 Collection을 사용한다 (Collection에 대한 Class를 재구현하지 않는다)

💡 .javaClass로 클래스에 대한 정보를 얻어올 수 있다

```kotlin
// 3개의 Collection 모두 read-only 
// set
val set = setOf(1,2,3)

// list
val list = listOf(1,2,3)

// map (key-value 구조이므로 to 사용)
val map = mapOf(1 to "one", 2 to "two", 3 to "three")

println(set.javaClass)
println(list.javaClass)
println(map.javaClass)
----------------------
class java.util.LinkedHashSet 
class java.util.Arrays$ArrayList
class java.util.LinkedHashMap
```

⭐ Java의 Collection을 그대로 사용하지만 추가로 더 유용하게 사용할 수 있다

> EX)
> 

```kotlin
fun main() {
	val strings = listOf("one","two","three")
	val numbers = setOf(1,2,3)
		
	println(strings.last())
	
	println(strings.shuffled())
	println(numbers.sum())
}
---------------------
three
[three, two, one]
6
```

### 함수 호출을 더 쉽게

Java의 Default로 구현된 toString과 다르게 출력하려면 third Party 라이브러리를 활용하거나 직접 로직을 구현해야하나 Kotlin은 표준 라이브러리에서 기본적으로 제공한다

```kotlin
fun main() {
	val list= listOf(1,2,3)
	// Default로 구현된 toString에 따라 출력
	print(list)
}
------------
[1,2,3]
------------

fun <T> joinToString(
	collection: Collection<T>,
	separator: String,
	prefix: String,
	postfix: String
) : String {
	val result=StringBuilder(prefix)
	
	for((index,element) in collection.withIndex()) {
		if(index>0) result.append(separator)
		result.append(element)
	}
	
	result.append(postfix)
	return result.toString()
}

fun main() {
	val list=listOf(1,2,3)
	println(joinToString(list,"; ","(",")"))
}
---------------
(1; 2; 3)
```

- 지명 인자
    
    ⭐ Java에서는 컴파일된 바이트코드에서 매개변수 이름이 유지되지 않아 지명인자를 지원하지 않는다 (매개변수 순서만 인식)
    
    - 위의 joinToString 메서드는 인자가 4개나 들어있고 어떤 순서로 입력을 해야하는지 다 파악하고 있어야 한다<br>
    → 함수의 시그니처만 보고는 파악하기 힘들다
    - 인자가 많은 경우 주석으로 이를 작성하는 것을 요구하기도 한다
    - Kotlin은 지명 인자를 지원하여 인자가 어떤 의미인지 파악하기 쉽고 순서를 지키지 않아도 된다<br>
    → 인자를 모두 명시해도 되고 일부만 명시해도 된다
    
    > EX)
    > 
    
    ```kotlin
    // Java
    joinToString(collection, /* seperator*/ " ", /*prefix*/, ",")
    
    // Kotlin
    joinToString(collection, seperator=" ", prefix=", " ...)
    ```
    
    ⭐ IntelliJ 나 Android Studio에서 함수의 인자를 바꿀 땐 직접 변경하지 말고 rename이나 Change Signaturre Action으로 일괄 변경하는 것이좋다
    
- 매개변수 기본 값
    
    ⭐ Java에서는 기본 값을 지원하지 않고 메서드 오버로딩을 사용해서 기본 값을 처리해야 한다 (함수 호출을 정적으로 결정하는 구조이기 때문에생성자를 여러개 만들어야 함)
    
    - Java의 특정 클래스에서는 과하게 많이 overload 된 메서드가 존재하여 반복적인 코드가 많아진다
    - 매개변수 값에 default 값을 지정할 수 있어 overload 된 메서드를 만들 필요가 없는 경우가 많다
    - 예시의 마지막처럼 생략할 때 함수의 시그니처만 보고 파악하기 어려운 경우가 있어 지명 인자와 함께 사용하면 시너지가 좋다
    - Default 값은 함수가 정의된 곳에 저장된다 (Call Site X)<br>
    → 기본 값이 바꾸고 호출할 때마다 새로운 기본 값을 사용하게 된다
    
    > EX)
    > 
    
    ```kotlin
    fun <T> joinToString(
    	collection: Collection<T>,
    	separator: String=", ",
    	prefix: String="",
    	postfix: String=""
    ) : String { ... }
    
    fun main() {
    	joinToString(list,", ","","")
    	joinToString(list)
    	// 이 경우 seperator가 ;가 된다 (생략하고자 하는 전까지는 순서 유지 필요)
    	joinToString(list,"; ")
    }
    ```
    
    💡 Java에서도 기본 값을 사용하려면 `@JvmOverloads` 를 사용하면 된다
    
    > EX)
    > 
    
    ```kotlin
     @JvmOverloads
     fun <T> joinToString(
     collection: Collection<T>,
     separator: String = ", ",
     prefix: String = "",
     postfix: String = ""
     ): String { /* ... */ }
     
    // @JvmOverloads를 붙이면 자동으로 오버라이딩 된 생성자를 만들어준다
     String joinToString(Collection<T> collection, String separator,
     String prefix, String postfix);
     
     String joinToString(Collection<T> collection, String separator,
     String prefix);
     
     String joinToString(Collection<T> collection, String separator);
     
     String joinToString(Collection<T> collection);
    ```
<br></br>
- 최상위 함수와 프로퍼티로 정적 유틸리티 클래스 제거
    - Java에서는 상태나 인스턴스 메서드를 포함하지 않는 Class가 많다</br>
    → EX) Collections 클래스
    - 이는 단순히 static method를 담고 있는 Class들 이다
    - Kotlin에서는 소스파일의 최상위에 함수를 선언만 해도 Java의 static 메서드 처럼 사용할 수 있다</br>
    → 다만 다른 패키지에서 사용하려면 import가 필요하다
    
    > EX) 최상위 함수 선언
    > 
    
    ```kotlin
    // Kotlin
    package strings
    
    fun joinToString( ... ) : String { ... } 
    
    // Java
    package strings;
    
    // 함수 선언을 위해 큰 의미없는 class로 감싸고 static 키워드가 붙는다
    public class JoinKt {
    	public static String joinToString(...) { ... }
    }
    
    // 활용
    import strings.JoinKt;
    
    JoinKt.joinToString(list, ", "," ", " ")
    
    ```
    
    - Jvm은 클래스에서만 코드를 실행할 수 있어 Kotlin 예시를 컴파일하면 일부 코드가 자동으로 생성된다</br>
    → Java 코드 예시와 같은 코드가 생성된다
    
    💡 컴파일러가 자동 생성해주는 Class 이름은 파일명과 동일하고 뒤에 Kt 접미사가 붙게 된다
    → Kotlin의 최상위 함수를 포함하는 Class의 이름을 변경하려면 파일 전체에 적용되는 `@file:JvmName("[설정하고 싶은 Class 이름]")` 를 package 선언 앞에 추가하면 된다
    
    > EX)
    > 
    
    ```kotlin
    @file:JvmName("StringFunctions")
    
    package strings
    
    fun joinToString( ... ) : String { ... }
    
    // 활용
    import strings.StringFunctions;
    StringFunctions.joinToString(list,",","","");
    ```
    

- 최상위 프로퍼티
    - 함수처럼 프로퍼티도 파일의 최상위에 선언될 수 있다</br>
    → static field에 저장된다
    - 상수를 선언할 때 좋다
    
    > EX)
    > 
    
    ```kotlin
    var count = 0
    fun performOperation() {
    	count++
    }
    
    fun repeatOperationCount() {
    	println("count : $count ")
    }
    
    // 상수 선언
    val PI = 3.141592
    
    // Kotlin
    const val BASE_URL = "localhost:8080"
    
    // Java
    public static final String BASE_URL ="localhost:8080"
    ```
    
    💡 Kotlin STL에는 여러 유용한 최상위 함수와 최상위 프로퍼티가 포함되어 있다</br>
    → EX) math 패키지의 max 함수, 오일러 수 등등
    

### 확장 함수와 확장 프로퍼티로 클래스에 메서드 쉽게 추가하기

Kotlin의 주요 특징 중 하나는 기존에 존재하는 코드에 통합이 쉽다는 것이다(확장성)

Java에 통합할 때 이미 존재하는 코드를 함께 다룰 때 기존의 코드를 재작성하지 않고 사용할 수 있도록 확장 함수가 도와준다

확장함수는 클래스 외부에서 정의된 함수이지만 클래스의 멤버 함수처럼 호출할 수 있다</br>
→ 아래 예시에서 String Class를 뜯어 고치지 않고 개발자가 정의한 함수를 쉽게 추가할 수 있었다

확장함수는 final 키워드가 붙어 상속이 불가능해도 상관 없다 (캡슐화도 깨지 않음 → private 과 proetected 멤버에 접근 불가능하다)

확장함수의 리시버 객체의 모든 메서드를 호출 가능하다

함수의 호출 부분에서는 확장함수인지 멤버함수인지 구별이 되지 않는다

```kotlin
package strings

// String 자로형 : reveiver Type => 어떤 자료형에 확장함수가 정의되어있는지
// this : receiver Object => 해당 reveiver Type의 인스턴스
// 일반 메서드의 this 처럼 사용할 수 있고 생략도 가능하다
fun String.lastChar() : Char = this.get(this.length-1)

// 활용
fun main() {
	println("Kotlin".lastChar())
}
-------------
n
```

- 확장함수와 Import 구문
    - 확장함수를 정의할 때 다른 패키지에서 자동적으로 사용하지 못하고 import 구문을 추가해줘야 한다</br>
    → 이름 충돌을 막기 위함
    - as 키워드로 import 하려는 함수나 메서드의 이름을 바꿀 수 있다</br>
    → 확장 함수는 짧은 이름만 사용 가능할 수 있어 as 키워드로 별칭을 둬 이름 충돌을 해결할 수 있다
    
    > EX)
    > 
    
    ```kotlin
    import strings.lastChar
    
    val c = "Kotlin".lastChar()
    --------------------------------
    import strings.lastChar as last
    
    val c = "Kotlin".last()
    
    ```

