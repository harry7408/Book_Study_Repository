# 함수 정의 및 호출

## 다루는 내용

1. Collection, 문자열, 정규 표현식을 다루는 함수
2. 지명 인자, 기본 매개변수 값, 중위 호출
3. 확장 함수 및 확장 프로퍼티를 통해 Java 라이브러리를 Kotiln에 적용
4. local, 최상위 함수와 프로퍼티를 통한 코드 구조화

### Kotlin에서 Collection 만드는 방법

- 앞 장에서 sefOf를 사용하여 Set Collection을 만든 것처럼 [collection name]Of 를 통해 원하는 Collection을 만들 수 있다<br>
→ Java의 표준 Collection을 사용한다 (Collection에 대한 Class를 재구현하지 않는다)

💡 .javaClass로 클래스에 대한 정보를 얻어올 수 있다

```kotlin
// 3개의 Collection 모두 read-only 
// set
val set = setOf(1,2,3)

// list
val list = listOf(1,2,3)

// map (key-value 구조이므로 to 사용)
val map = mapOf(1 to "one", 2 to "two", 3 to "three")

println(set.javaClass)
println(list.javaClass)
println(map.javaClass)
----------------------
class java.util.LinkedHashSet 
class java.util.Arrays$ArrayList
class java.util.LinkedHashMap
```

⭐ Java의 Collection을 그대로 사용하지만 추가로 더 유용하게 사용할 수 있다

> EX)
> 

```kotlin
fun main() {
	val strings = listOf("one","two","three")
	val numbers = setOf(1,2,3)
		
	println(strings.last())
	
	println(strings.shuffled())
	println(numbers.sum())
}
---------------------
three
[three, two, one]
6
```

### 함수 호출을 더 쉽게

Java의 Default로 구현된 toString과 다르게 출력하려면 third Party 라이브러리를 활용하거나 직접 로직을 구현해야하나 Kotlin은 표준 라이브러리에서 기본적으로 제공한다

```kotlin
fun main() {
	val list= listOf(1,2,3)
	// Default로 구현된 toString에 따라 출력
	print(list)
}
------------
[1,2,3]
------------

fun <T> joinToString(
	collection: Collection<T>,
	separator: String,
	prefix: String,
	postfix: String
) : String {
	val result=StringBuilder(prefix)
	
	for((index,element) in collection.withIndex()) {
		if(index>0) result.append(separator)
		result.append(element)
	}
	
	result.append(postfix)
	return result.toString()
}

fun main() {
	val list=listOf(1,2,3)
	println(joinToString(list,"; ","(",")"))
}
---------------
(1; 2; 3)
```

- 지명 인자
    
    ⭐ Java에서는 컴파일된 바이트코드에서 매개변수 이름이 유지되지 않아 지명인자를 지원하지 않는다 (매개변수 순서만 인식)
    
    - 위의 joinToString 메서드는 인자가 4개나 들어있고 어떤 순서로 입력을 해야하는지 다 파악하고 있어야 한다<br>
    → 함수의 시그니처만 보고는 파악하기 힘들다
    - 인자가 많은 경우 주석으로 이를 작성하는 것을 요구하기도 한다
    - Kotlin은 지명 인자를 지원하여 인자가 어떤 의미인지 파악하기 쉽고 순서를 지키지 않아도 된다<br>
    → 인자를 모두 명시해도 되고 일부만 명시해도 된다
    
    > EX)
    > 
    
    ```kotlin
    // Java
    joinToString(collection, /* seperator*/ " ", /*prefix*/, ",")
    
    // Kotlin
    joinToString(collection, seperator=" ", prefix=", " ...)
    ```
    
    ⭐ IntelliJ 나 Android Studio에서 함수의 인자를 바꿀 땐 직접 변경하지 말고 rename이나 Change Signaturre Action으로 일괄 변경하는 것이좋다
    
- 매개변수 기본 값
    
    ⭐ Java에서는 기본 값을 지원하지 않고 메서드 오버로딩을 사용해서 기본 값을 처리해야 한다 (함수 호출을 정적으로 결정하는 구조이기 때문에생성자를 여러개 만들어야 함)
    
    - Java의 특정 클래스에서는 과하게 많이 overload 된 메서드가 존재하여 반복적인 코드가 많아진다
    - 매개변수 값에 default 값을 지정할 수 있어 overload 된 메서드를 만들 필요가 없는 경우가 많다
    - 예시의 마지막처럼 생략할 때 함수의 시그니처만 보고 파악하기 어려운 경우가 있어 지명 인자와 함께 사용하면 시너지가 좋다
    - Default 값은 함수가 정의된 곳에 저장된다 (Call Site X)<br>
    → 기본 값이 바꾸고 호출할 때마다 새로운 기본 값을 사용하게 된다
    
    > EX)
    > 
    
    ```kotlin
    fun <T> joinToString(
    	collection: Collection<T>,
    	separator: String=", ",
    	prefix: String="",
    	postfix: String=""
    ) : String { ... }
    
    fun main() {
    	joinToString(list,", ","","")
    	joinToString(list)
    	// 이 경우 seperator가 ;가 된다 (생략하고자 하는 전까지는 순서 유지 필요)
    	joinToString(list,"; ")
    }
    ```
    
    💡 Java에서도 기본 값을 사용하려면 `@JvmOverloads` 를 사용하면 된다
    
    > EX)
    > 
    
    ```kotlin
     @JvmOverloads
     fun <T> joinToString(
     collection: Collection<T>,
     separator: String = ", ",
     prefix: String = "",
     postfix: String = ""
     ): String { /* ... */ }
     
    // @JvmOverloads를 붙이면 자동으로 오버라이딩 된 생성자를 만들어준다
     String joinToString(Collection<T> collection, String separator,
     String prefix, String postfix);
     
     String joinToString(Collection<T> collection, String separator,
     String prefix);
     
     String joinToString(Collection<T> collection, String separator);
     
     String joinToString(Collection<T> collection);
    ```
<br></br>
- 최상위 함수와 프로퍼티로 정적 유틸리티 클래스 제거
    - Java에서는 상태나 인스턴스 메서드를 포함하지 않는 Class가 많다</br>
    → EX) Collections 클래스
    - 이는 단순히 static method를 담고 있는 Class들 이다
    - Kotlin에서는 소스파일의 최상위에 함수를 선언만 해도 Java의 static 메서드 처럼 사용할 수 있다</br>
    → 다만 다른 패키지에서 사용하려면 import가 필요하다
    
    > EX) 최상위 함수 선언
    > 
    
    ```kotlin
    // Kotlin
    package strings
    
    fun joinToString( ... ) : String { ... } 
    
    // Java
    package strings;
    
    // 함수 선언을 위해 큰 의미없는 class로 감싸고 static 키워드가 붙는다
    public class JoinKt {
    	public static String joinToString(...) { ... }
    }
    
    // 활용
    import strings.JoinKt;
    
    JoinKt.joinToString(list, ", "," ", " ")
    
    ```
    
    - Jvm은 클래스에서만 코드를 실행할 수 있어 Kotlin 예시를 컴파일하면 일부 코드가 자동으로 생성된다</br>
    → Java 코드 예시와 같은 코드가 생성된다
    
    💡 컴파일러가 자동 생성해주는 Class 이름은 파일명과 동일하고 뒤에 Kt 접미사가 붙게 된다
    → Kotlin의 최상위 함수를 포함하는 Class의 이름을 변경하려면 파일 전체에 적용되는 `@file:JvmName("[설정하고 싶은 Class 이름]")` 를 package 선언 앞에 추가하면 된다
    
    > EX)
    > 
    
    ```kotlin
    @file:JvmName("StringFunctions")
    
    package strings
    
    fun joinToString( ... ) : String { ... }
    
    // 활용
    import strings.StringFunctions;
    StringFunctions.joinToString(list,",","","");
    ```
    

- 최상위 프로퍼티
    - 함수처럼 프로퍼티도 파일의 최상위에 선언될 수 있다</br>
    → static field에 저장된다
    - 상수를 선언할 때 좋다
    
    > EX)
    > 
    
    ```kotlin
    var count = 0
    fun performOperation() {
    	count++
    }
    
    fun repeatOperationCount() {
    	println("count : $count ")
    }
    
    // 상수 선언
    val PI = 3.141592
    
    // Kotlin
    const val BASE_URL = "localhost:8080"
    
    // Java
    public static final String BASE_URL ="localhost:8080"
    ```
    
    💡 Kotlin STL에는 여러 유용한 최상위 함수와 최상위 프로퍼티가 포함되어 있다</br>
    → EX) math 패키지의 max 함수, 오일러 수 등등
<br></br>   

### 확장 함수와 확장 프로퍼티로 클래스에 메서드 쉽게 추가하기

Kotlin의 주요 특징 중 하나는 기존에 존재하는 코드에 통합이 쉽다는 것이다(확장성)

Java에 통합할 때 이미 존재하는 코드를 함께 다룰 때 기존의 코드를 재작성하지 않고 사용할 수 있도록 확장 함수가 도와준다

확장함수는 클래스 외부에서 정의된 함수이지만 클래스의 멤버 함수처럼 호출할 수 있다</br>
→ 아래 예시에서 String Class를 뜯어 고치지 않고 개발자가 정의한 함수를 쉽게 추가할 수 있었다

확장함수는 final 키워드가 붙어 상속이 불가능해도 상관 없다 (캡슐화도 깨지 않음 → private 과 proetected 멤버에 접근 불가능하다)

확장함수의 리시버 객체의 모든 메서드를 호출 가능하다

함수의 호출 부분에서는 확장함수인지 멤버함수인지 구별이 되지 않는다

```kotlin
package strings

// String 자로형 : reveiver Type => 어떤 자료형에 확장함수가 정의되어있는지
// this : receiver Object => 해당 reveiver Type의 인스턴스
// 일반 메서드의 this 처럼 사용할 수 있고 생략도 가능하다
fun String.lastChar() : Char = this.get(this.length-1)

// 활용
fun main() {
	println("Kotlin".lastChar())
}
-------------
n
```

- 확장함수와 Import 구문
    - 확장함수를 정의할 때 다른 패키지에서 자동적으로 사용하지 못하고 import 구문을 추가해줘야 한다</br>
    → 이름 충돌을 막기 위함
    - as 키워드로 import 하려는 함수나 메서드의 이름을 바꿀 수 있다</br>
    → 확장 함수는 짧은 이름만 사용 가능할 수 있어 as 키워드로 별칭을 둬 이름 충돌을 해결할 수 있다
    
    > EX)
    > 
    
    ```kotlin
    import strings.lastChar
    
    val c = "Kotlin".lastChar()
    --------------------------------
    import strings.lastChar as last
    
    val c = "Kotlin".last()
    
    ```

- 확장함수와 Import 구문
    - 확장함수를 정의할 때 다른 패키지에서 자동적으로 사용하지 못하고 import 구문을 추가해줘야 한다
    → 이름 충돌을 막기 위함
    - as 키워드로 import 하려는 함수나 메서드의 이름을 바꿀 수 있다
    → 확장 함수는 짧은 이름만 사용 가능할 수 있어 as 키워드로 별칭을 둬 이름 충돌을 해결할 수 있다
    
    > EX)
    > 
    
    ```kotlin
    import strings.lastChar
    
    val c = "Kotlin".lastChar()
    --------------------------------
    import strings.lastChar as last
    
    val c = "Kotlin".last()
    
    ```
<br></br>    
- Java에서 확장 함수 호출하기
    - 내부적으로 확장 함수는 첫 번째 인자로 리시버 객체를 받는 정적 메서드로 변환된다</br>
    → 별도 어뎁터 객체를 만들거나 런타임 오버헤드를 일으키지 않는다
    - Java에서 사용할 때 static 메서드를 호출하면서 리시버 객체를 첫 번째 인자로 넣으면 된다
    - Top-level 함수와 마찬가지로 확장 함수를 포함하는 Class 이름은 함수가 선언된 파일의 이름을 기반으로 결정된다
    - 확장 함수가 Top-level로 선언되면 컴파일 시 static 메서드로 변환되므로 import 하여 사용할 수 있다
    
    > EX)
    > 
    
    ```kotlin
    char c = StringUtilKt.lastChar("Hello");
    ```    
<br></br>
- 확장 함수로 Utility 함수 만들기
    - 위에서 만든 joinToString() 메서드로 살펴본다
    → Kotlin의 STL에서 볼 수 있는 형태
    - 확장 함수는 정적 메서드 호출을 감싸는 문법적 편의에 불과하여 receiver 타입으로 클래스 뿐만 아니라 구체적인 타입을 사용할 수 있다
    
    > EX) joinToString
    > 
    
    ```kotlin
    // Collection의 Extensiton Func
    fun <T> Collection<T>.joinToString(
    	separator: String =", ",
    	prefix: String = "",
    	postfix: String ="",
    ) : String {
    	val result = StringBuilder(prefix)
    	
    	// this는 활용되는 Collection 제네릭 타입 객체를 의미
    	for((index, element) in this.withIndex()) {
    		if(index>0) result.append(separator)
    		result.append(element)
    	}
    	result.append(postfix)
    	return result.toString()
    }
    
    // 활용 1 : 지명인자로 값 넘겨주기
    fun main() {
    	val list = listOf(1, 2, 3)
    	println(
    		list.joinToString(
    			separator="; ",
    			prefix="(",
    			postfix=")"
    			)
    	)
    }
    ---------------
    (1; 2; 3)
    ---------------
    // 활용 2 : Default 값 사용
    fun main() {
    	val list = listOf(1, 2, 3)
    	println(list.joinToString(" "))
    }
    -----------------
    1 2 3
    ```
    
    > EX) 구체적인 타입만 사용하는 확장 함수 (Not Generic)
    > 
    
    ```kotlin
    fun Colletion<String>.join(
    		separator: String = ", ",
    		prefix: String = "",
    		postfix: String= ""
    ) = joinToString(separator,prefix,postfix)
    
    fun main() {
    	println(listOf("one", "two", "three"),join(" "))
    	// 에러 발생 (receiver type mismatch)
    	listOf(1,2,3).join()
    }
    ---------------
    one two three
    ```
<br></br>
- 확장 함수의 특성 : 오버라이딩 불가능
    - 확장 함수는 static method로 컴파일 되기 때문에 SubClass에서 오버라이딩 할 수 없다</br>
    → 확장 함수는 Class 내부가 아닌 외부에서 정의되기 때문에 오버라이딩 불가능 하다
    - 한 Class와 그의 subClass가 같은 이름과 매개 변수 수가 같은 확장 함수를 정의하더라도 호출되는 함수는 변수의 **Runtime이 아니라 컴파일 타임에 결정된 정적 타입에 따라 달라진다**
    
    > EX) 일반적인 오버라이딩
    > 
    
    ```kotlin
    open class View {
    	open fun click() = println("View Clicked")
    }
    
    class Button : View() {
    	override fun click() = println("Button Clicked")
    }
    
    fun main() {
    	// 상속의 특성
    	val view : View = Button()
    	view.click()
    }
    ---------------
    // 실제 Button 타입의 객체가 생성되어 Override 된 click 함수가 호출된다
    Button Clicked
    ```
    
    > Ex) 부모 자식 Class 간 확장 함수를 같은 이름의 메서드로 구성
    > 
    
    ```kotlin
    fun View.showOff() = println("It's a View")
    fun Button.showOff() = println("It's a Button")
    
    fun main() {
    	val view : View = Button()
    	view.showOff()
    }
    ---------------
    It's a View
    ---------------
    // Java
    class Example {
    	public static void main(String[] args) {
    		View view = new Button();
    		ExtensitonsKt.showOff(view);
    	}
    }
    ---------------
    It's a View
    ```
  
    💡 Class와 확장함수와 동일한 함수 시그니처를 갖는 멤버함수가 존재한다면 항상 멤버 함수가 우선적으로 호출된다</br>
    → IDE에서도 만든 확장함수가 가려질 것이라는 경고를 준다
<br></br>
- 확장 프로퍼티
    - 확장 함수처럼 확장 프로퍼티를 명시할 수 있다</br>
    → 기존 클래스에 API를 확장할 수 있고 함수의 문법이 아닌 프로퍼티 문법으로 접근 가능하다
    - 확장 프로퍼티는 실제 상태를 가질 수 없다</br>
    → Java 객체의 인스턴스에 새로운 Field를 추가할 수 없기 때문이다
    - 실제 상태를 가질 수 없어 custom accessors(사용자 정의 getter ,setter)를 정의 해줘야 한다</br>
    **→ backing field가 없어 getter, setter 를 직접 구현해줘야 하고 초기화식도 사용할 수 없다**
    - 확장 함수와 마찬가지고 리시버 타입이 추가된 일반적인 Class의 프로퍼티처럼 보인다
    
    > EX) 확장 프로퍼티
    > 
    
    ```kotlin
    val String.lastChar : Char
    // 사용자 정의 접근자 : getter
    	get() = this.get(length-1)
    
    // StringBuilder는 내용 변경이 가능하기 때문에 var로 설정
    var StringBuilder.lastChar: Char
    	get() = this.get(length-1)
    	set(value) {
    		this.setCharAt(length-1,value)
    	}
    
    fun main() {
    	val sb=StringBuilder("Kotlin?")
    	println(sb.lastChar)
    	
    	sb.lastChar(".")
    	println(sb)
    }
    ------------
    ?
    Kotlin.
    -----------
    // Java에서는 get, set을 명시적으로 호출해야 한다
    StringUtilKt.getLastChar("Kotlin?")
    StringUtilKt.setLastChar(".")
    ```
<br></br>
### Collection 활용(가변 인자, 중위 표기법, 라이브러리)

Collection을 활용하기 위한 Kotlin STL 함수들에 대해서 살펴본다

1. 가변 인자 : 임의의 수의 인자를 받을 수 있는 함수를 선언할 수 있도록 해준다
2. 중위 표기법 : 단일 인수 함수를 더 간결하게 호출할 수 있도록 해준다
3. 구조 분해 선언 : 단일 값을 여러 개의 변수로 분해하여 할당할 수 있게 해준다

- Java Collection API 확장
    - Kotlin의 Collections은 Java와 같은 Class를 사용하나 특별한 설정 없이 추가적인 API를 제공해준다</br>
    **→ API 들이 확장 함수로 선언되어 있으며 모든 Kotlin 파일에서 기본적으로 import 되기 때문이다** (많은 확장함수가 Kotlin STL에 정의되어 있다)
    
    > EX) Kotlin Collections
    > 
    
    ```kotlin
    fun main() {
    	val strings : List<String> = listOf("one","two","three")
    	// last() API
    	strings.last()
    	
    	val numbers : Collection<Int> = setOf(1,2,3)
    	// sum() API
    	numbers.sum()
    }
    
    // 두 API의 형태 (Extension Func)
    fun <T> List<T>.last() : T { ... }
    fun Collections<Int>.sum() : Int { ... } 
    ```    
 <br></br>
- 임의의 인자를 받을 수 있는 함수 by 가변인자
    - 위의 예시에서 list를 만들 때 임의의 갯수의 인자를 전달했다
    - Java의 varargs와 기능이 유사하지만 문법 형태가 다르다</br>
    → Java에선 `...`  Kotlin에선 `vararg` 키워드 사용
    - 배열을 vararg 함수에 전달할 때 Java와 Kotlin이 문법 차이를 보인다</br>
    → Java에선 배열 그대로 전달 Kotlin에선 개별 인자로 변환하기 위해 `*` 연산자 활용
    
    > EX)  varargs
    > 
    
    ```kotlin
    val list = listOf(1,2,3,4,5)
    
    // listOf 의 시그니쳐
    fun listOf<T> (vararg values: T) : List<T> { ... }
    
    // Kotlin에서 배열 인자 전달하기
    fun main(args : Array<String>) {
    	val list=listOf("args: ", *args)
    	println(list)
    }
    
    fun testMain() {
        println("Test 1:")
        main(arrayOf("Hello", "Kotlin", "World"))
    
        println("\nTest 2:")
        main(arrayOf("Kotlin", "is", "awesome"))
    
        println("\nTest 3 (Empty):")
        main(arrayOf()) 
    }
    
    ---------------
    [args: ]
    ---------------
    // Test 메서드
    Test 1:
    [args: , Hello, Kotlin, World]
    
    Test 2:
    [args: , Kotlin, is, awesome]
    
    Test 3 (Empty):
    [args: ]
    ```

